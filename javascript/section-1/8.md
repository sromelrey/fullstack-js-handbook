[← Back to Main Guide](../README.md) | [📚 JavaScript: Understanding the Weird Parts - Conceptual Refresher](../README.md)

# Function Invocation and the Execution Stack - Conceptual Refresher

## Summary

- **Function Invocation**: Simply means calling or running a function using parentheses
- **Execution Stack**: A stack data structure that manages execution contexts, with the top context being the currently running one
- **New Execution Context**: Every function invocation creates a new execution context and places it on the execution stack
- **Stack Management**: Functions are pushed onto the stack when invoked and popped off when they complete
- **Synchronous Execution**: The execution stack ensures synchronous, line-by-line execution within each context

## Core Concepts & Mechanics

### Function Invocation: The Simple Truth

Function invocation is simply calling a function using parentheses:

```javascript
// Function invocation examples
function myFunction() {
  console.log("Function called");
}

myFunction(); // Invoking the function
myFunction(); // Invoking it again
myFunction(); // Invoking it a third time

// Each invocation creates a new execution context
```

**Critical Insight**: "Invocation" is just a fancy word for "calling a function" - it's not as complex as it sounds.

### The Execution Stack: Context Management

The execution stack is a stack data structure that manages execution contexts:

```javascript
function a() {
  console.log("Function a executing");
  b(); // Invoke function b
  console.log("Function a finishing");
}

function b() {
  console.log("Function b executing");
}

a(); // Invoke function a

// Execution stack behavior:
// 1. Global context (bottom of stack)
// 2. Function a context (pushed on top)
// 3. Function b context (pushed on top of a)
// 4. Function b completes (popped off)
// 5. Function a continues (back on top)
// 6. Function a completes (popped off)
// 7. Global context continues (back on top)
```

**Key Understanding**: The execution stack manages which execution context is currently running, with the top context being active.

### New Execution Context Creation

Every function invocation creates a new execution context:

```javascript
function outerFunction() {
  var outerVar = "outer";

  function innerFunction() {
    var innerVar = "inner";
    console.log(outerVar, innerVar);
  }

  innerFunction(); // Creates new execution context
}

outerFunction(); // Creates new execution context

// Each function gets its own:
// - Variable environment
// - 'this' binding
// - Outer environment reference
// - Creation and execution phases
```

**Important Pattern**: Each function invocation creates a completely new execution context with its own memory space and variables.

### Stack Push and Pop Operations

Functions are pushed onto the stack when invoked and popped off when they complete:

```javascript
function first() {
  console.log("First function start");
  second(); // Push second() onto stack
  console.log("First function end");
}

function second() {
  console.log("Second function start");
  third(); // Push third() onto stack
  console.log("Second function end");
}

function third() {
  console.log("Third function start");
  console.log("Third function end");
  // Pop third() off stack
}

first(); // Push first() onto stack

// Stack operations:
// Push: first() -> second() -> third()
// Pop:  third() -> second() -> first()
```

**Critical Pattern**: The stack follows LIFO (Last In, First Out) behavior - the most recently invoked function runs first.

### Lexical Order vs Execution Order

The lexical order of functions doesn't matter - only the invocation order matters:

```javascript
// Lexical order: a is above b
function a() {
  console.log("Function a");
  b(); // Invoke b
}

function b() {
  console.log("Function b");
}

// Execution order depends on invocation, not lexical position
a(); // a executes first, then b

// Even if we reorder lexically:
function b() {
  console.log("Function b");
}

function a() {
  console.log("Function a");
  b(); // Still invokes b
}

a(); // Same execution order
```

**Key Insight**: Function execution order depends on invocation order, not where functions are defined in the code.

## Key Insights & Gotchas

• **Invocation Simplicity**: Function invocation is just calling a function with parentheses - don't overthink it

• **Stack Management**: The execution stack manages which execution context is currently running

• **New Context Per Invocation**: Every function invocation creates a new execution context, even if it's the same function

• **Stack Push/Pop**: Functions are pushed onto the stack when invoked and popped off when they complete

• **Top of Stack**: The execution context at the top of the stack is the one currently running

• **Lexical vs Execution Order**: Function execution order depends on invocation order, not lexical position

• **Synchronous Execution**: The stack ensures synchronous, line-by-line execution within each context

• **Context Isolation**: Each function gets its own execution context with its own variables and memory space

• **Stack Depth**: Deep function calls create deep stacks - each level adds to the stack

• **Completion Order**: Functions complete in reverse order of invocation (LIFO - Last In, First Out)

• **Global Context**: The global execution context is always at the bottom of the stack

• **Recursive Functions**: Recursive functions create multiple execution contexts on the stack

• **Memory Management**: Each execution context has its own memory space for variables and functions

• **Outer Environment**: Each execution context maintains a reference to its outer environment

• **Stack Overflow**: Deep recursion can cause stack overflow if the stack becomes too deep

• **Debugging Tool**: Understanding the execution stack helps debug complex function call patterns
