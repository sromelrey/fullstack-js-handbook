[â† Back to Main Guide](../README.md) | [ðŸ“š JavaScript: Understanding the Weird Parts - Conceptual Refresher](../README.md)

# Conceptual Aside: Operators as Functions - Conceptual Refresher

## Summary

- **Operators Are Functions**: All JavaScript operators are special functions with unique syntax - they take parameters and return values just like regular functions
- **Infix Notation**: JavaScript uses infix notation where the operator sits between its parameters, making code more human-readable than function calls
- **Type-Dependent Behavior**: Operators behave differently based on the types of their parameters, which is crucial in a dynamically-typed language
- **Pre-written Engine Code**: The JavaScript engine provides pre-written implementations for all operators, handling type coercion and edge cases internally
- **Function Call Abstraction**: Operators abstract away the complexity of function calls for common operations, but they're still function calls under the hood

## Core Concepts & Mechanics

### Operators: Special Functions with Unique Syntax

Every operator in JavaScript is fundamentally a function call, but with syntax that makes it more readable than traditional function notation:

```javascript
// Traditional function call
function add(a, b) {
  return a + b;
}
var result = add(3, 4); // Function call with parentheses

// Operator as function call (infix notation)
var result = 3 + 4; // Same operation, different syntax
console.log(result); // 7

// The engine sees the operator as a function call
// Internally: plus(3, 4) -> returns 7
```

**Critical Insight**: The plus sign is not magic - it's a function call with special syntax that the engine recognizes and processes.

### Infix vs. Prefix vs. Postfix Notation

JavaScript uses infix notation for most operators, but understanding the alternatives helps clarify the function nature:

```javascript
// Infix notation (JavaScript standard)
var sum = 3 + 4; // Operator between parameters
var diff = 7 - 2; // Operator between parameters
var isGreater = 4 > 3; // Operator between parameters

// Prefix notation (hypothetical)
// var sum = +(3, 4);    // Would be: plus(3, 4)
// var diff = -(7, 2);   // Would be: minus(7, 2)

// Postfix notation (hypothetical)
// var sum = (3, 4)+;    // Would be: (3, 4).plus()
// var diff = (7, 2)-;   // Would be: (7, 2).minus()

// JavaScript does use prefix for some operators
var negative = -5; // Unary minus (prefix)
var positive = +"5"; // Unary plus (prefix, type coercion)
```

**Key Understanding**: Infix notation is chosen for readability, but it's still a function call with two parameters and a return value.

### Type-Dependent Operator Behavior

Operators behave differently based on the types of their parameters, which is crucial in JavaScript's dynamic typing system:

```javascript
// Same operator, different behaviors based on types
console.log(3 + 4); // 7 (numeric addition)
console.log("3" + "4"); // "34" (string concatenation)
console.log(3 + "4"); // "34" (type coercion to string)
console.log("3" + 4); // "34" (type coercion to string)

// Comparison operators return different types
console.log(4 > 3); // true (boolean)
console.log(4 + 3); // 7 (number)
console.log("4" > "3"); // true (string comparison)
console.log("4" > 3); // true (type coercion to number)
```

**Critical Pattern**: The same operator symbol can produce completely different results based on parameter types - this is where dynamic typing creates complexity.

### Operator Function Implementation

The JavaScript engine provides pre-written implementations for all operators, handling type coercion and edge cases:

```javascript
// What the engine does internally for the + operator
function plus(left, right) {
  // Engine's internal logic (simplified)
  if (typeof left === "string" || typeof right === "string") {
    return String(left) + String(right); // String concatenation
  } else {
    return Number(left) + Number(right); // Numeric addition
  }
}

// Your code: 3 + "4"
// Engine calls: plus(3, "4")
// Engine logic: String(3) + String("4") = "3" + "4" = "34"
console.log(3 + "4"); // "34"

// Your code: 3 + 4
// Engine calls: plus(3, 4)
// Engine logic: Number(3) + Number(4) = 3 + 4 = 7
console.log(3 + 4); // 7
```

**Critical Understanding**: The engine's operator functions contain complex logic for type coercion and edge cases that developers don't see.

### Operator Return Types

Different operators return different types, which affects how they can be used in expressions:

```javascript
// Arithmetic operators return numbers (usually)
console.log(3 + 4); // 7 (number)
console.log(3 - 4); // -1 (number)
console.log(3 * 4); // 12 (number)
console.log(3 / 4); // 0.75 (number)

// Comparison operators return booleans
console.log(3 > 4); // false (boolean)
console.log(3 < 4); // true (boolean)
console.log(3 === 4); // false (boolean)
console.log(3 !== 4); // true (boolean)

// Logical operators return the last evaluated value
console.log(3 && 4); // 4 (last truthy value)
console.log(0 && 4); // 0 (first falsy value)
console.log(3 || 4); // 3 (first truthy value)
console.log(0 || 4); // 4 (first truthy value)
```

**Key Pattern**: Understanding what each operator returns is essential for predicting behavior in complex expressions.

## Key Insights & Gotchas

â€¢ **Operators Are Functions**: Every operator is a special function call with unique syntax - there's no magic, just pre-written engine code

â€¢ **Infix Notation Choice**: JavaScript uses infix notation (operator between parameters) for readability, but it's still a function call under the hood

â€¢ **Type-Dependent Behavior**: The same operator symbol can produce completely different results based on parameter types - this is where dynamic typing creates complexity

â€¢ **Engine Implementation**: The JavaScript engine provides pre-written implementations for all operators, handling type coercion and edge cases internally

â€¢ **Function Call Abstraction**: Operators abstract away the complexity of function calls for common operations, making code more readable

â€¢ **Return Type Variety**: Different operators return different types (numbers, booleans, or last evaluated values) - understanding this is crucial for complex expressions

â€¢ **Type Coercion Complexity**: Operator functions contain complex logic for type coercion that developers don't see, leading to unexpected behaviors

â€¢ **Dynamic Typing Impact**: In a dynamically-typed language, operators must handle any combination of types, making their internal logic more complex

â€¢ **Syntax vs. Semantics**: The syntax of operators (infix notation) is different from their semantics (function calls) - this distinction is important for understanding

â€¢ **Engine Optimization**: Operators are optimized by the engine for performance, but they still follow the same function call pattern

â€¢ **Debugging Implication**: When operators behave unexpectedly, it's often due to type coercion happening inside the operator function

â€¢ **Interview Critical**: Understanding that operators are functions is essential for explaining JavaScript's behavior in type coercion scenarios
